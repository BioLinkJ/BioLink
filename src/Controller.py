'''
BioLink - Tool for synchronized psycho-physiological and behavioural data acquisition
Copyright (C) 2017  Julian Schneider, Department of Internal Medicine, 
                    University Hospital Zurich, Zurich, Switzerland.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

-----------------------------------------------------------------
The Controller module contains all the functions to handle different events
generated by the user interface.
'''
import gi
gi.require_version('Gtk', '3.0')
from gi.repository import Gtk, GLib
import os.path
import threading

from BioLinkView import view
import PluxInterface
import MsgLogger
import ExpController
from SettingsModel import settingsModel
import LogTools
import ExtensionInterface as ei
import PreventSleep

SETTINGS_FILE_PATH = "../settings.json"
isExperimentRunning = False
subjectId = ""
extNameList = None

_emergencyTimeoutId = None


def init(): 
    global extNameList
    
    extNameList = ei.enumerateExtensionNames()
    extNameList.insert(0,'None')    #insert entry None at beginning of list
     
    view.btStart.set_sensitive(True)
    view.btEnd.set_sensitive(False)
    
    view.initExtensionComboBox(extNameList)
    
    #read settings from file
    loadSettings()
    setViewSettingsFromModel()
    
    ExpController.notifyExpEndFnc = _endExperimentCallback
       

  
def onDeleteWindow():
    #check experiments running
    if isExperimentRunning == True:
        warningDialog("Please end the current experiment before closing.")
        return True     #stops window from being destroyed
    else:
        #save settings
        updateModelWithSettings()
        saveSettings()
        
        ExpController.closePlot()
        ExpController.serialClose()
        #plux device already closed on experiment end
        
        Gtk.main_quit()
        return False
  
def startExperiment():
    global isExperimentRunning, subjectId
    
    #read settings from GUI
    if updateModelWithSettings():
        subjectId = view.teSubjectId.get_text().strip()
        
        ExpController.configChannels(settingsModel.settingsDict['channelNames'])
        ExpController.serialPort = settingsModel.settingsDict['serialPort']
        ExpController.experimentId = settingsModel.settingsDict['experimentId']
        ExpController.pluxMac = settingsModel.settingsDict['pluxMac']
        ExpController.fs = settingsModel.settingsDict['sampleRate']     #must be set before setMaxDuration
        ExpController.setMaxDuration( settingsModel.settingsDict['maxDuration'] )
        ExpController.useSerial = settingsModel.settingsDict['useSerial']
        ExpController.useLifePlot = settingsModel.settingsDict['useLifePlot'] 
        ExpController.reopenLifePlot = settingsModel.settingsDict['reopenLifePlot']
        ExpController.extensionName = settingsModel.settingsDict['extension']
        
        #open plux, abort on failure
        try:
            dialog = Gtk.MessageDialog(parent=view.window, type=Gtk.MessageType.INFO, buttons=Gtk.ButtonsType.NONE, text="Opening Plux device. This can take a few seconds...")
            dialog.show()   #give user immediate feedback
            
            while Gtk.events_pending():     #do pending events so dialog is shown
                Gtk.main_iteration()
                
            ExpController.pluxOpenDevice()
            dialog.destroy()
        except Exception as e:
            dialog.destroy()
            MsgLogger.append("Error opening Plux device: " + e.message)
            warningDialog("Error opening Plux device: " + e.message)
            return
        
        PreventSleep.preventSleep()
        
        #open serial port
        if settingsModel.settingsDict['useSerial']:
            try:
                ExpController.serialOpen(True) 
            except Exception as e:
                MsgLogger.append("Error opening serial port: " + e.message)
                
                    
        if subjectId == "":     #if no subject id entered and serial NOT present
            if ExpController.isSerialOpen.is_set():
                #if no subject id entered and serial present: dialog to receive over serial port
                receiveSubjectIdFromSerial()
            else:
                warningDialog("Please enter Subject ID or attach serial port.")
        
        
        if subjectId != "":      #subjectId was received or entered            
            #change button sensitivity
            view.btStart.set_sensitive(False)
            view.btEnd.set_sensitive(True)
            view.freezeSettings(True)
            
            saveSettings()      #save settings to file
            
            isExperimentRunning = True
            MsgLogger.append("Start experiment with Subject ID: '" + subjectId + "'")
            
            ExpController.startExperiment(subjectId)
            ExpController.extensionStart()
        else:
            #close serial port
            ExpController.serialClose()
            ExpController.pluxCloseDevice()
            PreventSleep.allowSleep()
            


def _endExperimentCallback():   #called by ExpController logging thread when finished
    GLib.idle_add(_endExperiment)   #add GUI operations to GTK main thread
                  
def _endExperiment():
    global isExperimentRunning, _emergencyTimeoutId
    
    ExpController.extensionEnd()
    
    #close serial port
    ExpController.serialClose()
    #plux device is closed when program exits (reopening plux device does not work)
  
    #change button sensitivity
    view.btStart.set_sensitive(True)
    view.btEnd.set_sensitive(False)
    view.freezeSettings(False)
    view.teSubjectId.set_text("")   #clear subject id for next run
    
    isExperimentRunning = False
    if _emergencyTimeoutId:     #experiment was attempted to be ended by GUI button (funciton endExperiment)
        GLib.source_remove(_emergencyTimeoutId)     #remove timeout as experiment was ended properly
        _emergencyTimeoutId = None
        
    MsgLogger.append("Experiment ended")
    
    PreventSleep.allowSleep()
    
def _endExperimentDetectEmergency():
    if isExperimentRunning:     #check whether experiment has been ended, otherwise force it (recover log)
        ExpController.forceStopExperiment()
    return False    #not executed another time

def endExperiment(): 
    global _emergencyTimeoutId   
    ExpController.stopExperiment()
    #ExpLogger thread should call _endExperimentCallback when done
    
    #wait with timer for tread to stop, otherwize force safe log
    _emergencyTimeoutId = GLib.timeout_add(11000,_endExperimentDetectEmergency)     #after 11 seconds, check whether experiment was ended properly
    
def findSerialPorts():
    portList = ExpController.serialEnumPorts()
    
    msg = "Serial Ports:"
    
    if len(portList) == 0:
        msg = msg + " no ports found"
    else:
        for p in portList:
            msg = msg + "\n\t" + p[0] + ": " + p[1]
    
    MsgLogger.append(msg)
    
def findPluxDevices():
    #weird effect: plot process needs to be ended to open plux again!!!
    ExpController.closePlot()     #close old plot if any
       
    dialog = Gtk.MessageDialog(parent=view.window, type=Gtk.MessageType.INFO, buttons=Gtk.ButtonsType.NONE, text="Searching Plux devices. This can take a few seconds...")
    dialog.show()   #give user immediate feedback
    
    while Gtk.events_pending():     #do pending events so dialog is shown
        Gtk.main_iteration()
    
    msg = "Plux Devices:"
    
    try:
        deviceTuple = PluxInterface.enumDevices()
        
        if len(deviceTuple) == 0:
            msg = msg + " no devices found"
        else:
            for d in deviceTuple:
                msg = msg + "\n\t" + d[0] + ": " + d[1]
        
    except Exception as e:
        msg = msg + " " + str(e)
    
    dialog.destroy()
    MsgLogger.append(msg)
    
def convertLogToTxt():
    #choose file to load
    openDialog = Gtk.FileChooserDialog("Please choose a log file", view.window,
            Gtk.FileChooserAction.OPEN,
            (Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
             Gtk.STOCK_OPEN, Gtk.ResponseType.OK))
    
    openFilter = Gtk.FileFilter()
    openFilter.set_name("npz files")
    openFilter.add_pattern("*.npz")
    openDialog.add_filter(openFilter)
    
    openDialog.set_current_folder(ExpController.logDir)
    
    response = openDialog.run()
    
    baseName = None
    
    if response == Gtk.ResponseType.OK:
        openFile = openDialog.get_filename()
        baseName = openFile[:-4]    #cut '.npz' at end
        
    openDialog.destroy()
    
    if baseName:
        saveDialog = Gtk.FileChooserDialog("Choose location for txt file", view.window,
            Gtk.FileChooserAction.SAVE,
            (Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
             Gtk.STOCK_SAVE, Gtk.ResponseType.OK))
        
        saveFilter = Gtk.FileFilter()
        saveFilter.set_name("Text files")
        saveFilter.add_pattern("*.txt")
        saveDialog.add_filter(saveFilter)
        
        saveDialog.set_current_folder(ExpController.logDir)
        saveDialog.set_current_name(os.path.basename(baseName) + '.txt')
        
        response = saveDialog.run()
        
        saveFile = None
        if response == Gtk.ResponseType.OK:
            saveFile = saveDialog.get_filename()
            
            if not saveFile[-4:] == '.txt':     #ensure name ends with '.txt'
                saveFile = saveFile + '.txt'
                
        saveDialog.destroy()
        
        if saveFile:
            converter = threading.Thread(target=_converterThread,args=(baseName, saveFile))
            converter.setDaemon(True)
            converter.start()
        
def _converterThread(baseName, saveFile):
    LogTools.exportTxt(baseName, saveFile)
    MsgLogger.append("Converted '" + baseName + ".npz' to '" + saveFile + "'")
    
def plotBioLinkData():
    openDialog = Gtk.FileChooserDialog("Please choose a log file", view.window,
            Gtk.FileChooserAction.OPEN,
            (Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
             Gtk.STOCK_OPEN, Gtk.ResponseType.OK))
    
    openFilter = Gtk.FileFilter()
    openFilter.set_name("npz files")
    openFilter.add_pattern("*.npz")
    openDialog.add_filter(openFilter)
    
    openDialog.set_current_folder(ExpController.logDir)
    
    response = openDialog.run()
    
    baseName = None
    
    if response == Gtk.ResponseType.OK:
        openFile = openDialog.get_filename()
        baseName = openFile[:-4]    #cut '.npz' at end
        
    openDialog.destroy()
    
    if baseName:
        LogTools.plotBioLinkData(baseName)
    
def updateModelWithSettings():
    """ returns True on success, False if settings have problems -> experiment should not start
    """
    errcnt = 0
    #{'channelNames': ('ECG', 'EDA', 'BVP'), 'pluxMac': '00:07:80:79:6F:E0', 
    #'experimentId': 'test', 'serialPort': 'COM1'}
    
    d = {'serialPort': view.teSerialPort.get_text().strip(), 
         'pluxMac': view.tePluxMac.get_text().strip(),
         'experimentId': view.teExperimentId.get_text().strip(),
         'useSerial': view.cbUseSerial.get_active(),
         'useLifePlot': view.cbUseLifePlot.get_active(),
         'reopenLifePlot': view.cbReopenLifePlot.get_active(),
         'extension': extNameList[ view.cbExtension.get_active() ]}
    
    settingsModel.updateSettings(d)
    
    #call parsing of channel names separately
    success = settingsModel.setChannelNamesStr( view.teChannelNames.get_text() )
    
    if success:
        if len(settingsModel.settingsDict['channelNames']) == 0:
            success = False
            
    if not success:
        warningDialog("Invalid Channel Names. Please review settings.")
        errcnt += 1
    
    if not settingsModel.setMaxDurationStr( view.teMaxDuration.get_text() ):
        errcnt += 1
        warningDialog("Invalid Max. Duration. Please review settings.")
        
    if not settingsModel.setSampleRateStr( view.teSampleRate.get_text() ):
        errcnt += 1
        warningDialog("Invalid Sample Rate. Please review settings.")
    
    setViewSettingsFromModel()      #update view with model
    
    
    if errcnt == 0:
        return True
    else:
        return False
        
        
def setViewSettingsFromModel():
    view.teSerialPort.set_text( settingsModel.settingsDict['serialPort'] )
    view.tePluxMac.set_text( settingsModel.settingsDict['pluxMac'] )
    view.teExperimentId.set_text( settingsModel.settingsDict['experimentId'] )
    view.teChannelNames.set_text( settingsModel.getChannelNamesStr() )
    view.teMaxDuration.set_text( settingsModel.getMaxDurationStr() )
    view.teSampleRate.set_text( settingsModel.getSampleRateStr() )
    view.cbUseSerial.set_active( settingsModel.settingsDict['useSerial'] )
    view.cbUseLifePlot.set_active( settingsModel.settingsDict['useLifePlot'] )
    view.cbReopenLifePlot.set_active( settingsModel.settingsDict['reopenLifePlot'] )
    
    if settingsModel.settingsDict['extension'] in extNameList:
        view.cbExtension.set_active( extNameList.index(settingsModel.settingsDict['extension']) )
    else:
        view.cbExtension.set_active (0)
    
def resetSettings():
    settingsModel.setToDefaultValues()
    setViewSettingsFromModel()
    
def loadSettings():
    try:
        with open(SETTINGS_FILE_PATH,"r") as f:
            settingsModel.loadSettings(f)
    except Exception as e:
        MsgLogger.append("Error loading '" + SETTINGS_FILE_PATH + "': " + str(e))

def saveSettings():
    try:
        with open(SETTINGS_FILE_PATH,"w") as f:
            settingsModel.dumpSettings(f)
    except:
        MsgLogger.append("Error saving to '" + SETTINGS_FILE_PATH + "'.")
        
def warningDialog(msg):
    dialog = Gtk.MessageDialog(parent=view.window, type=Gtk.MessageType.WARNING, buttons=Gtk.ButtonsType.OK, text=msg)
    dialog.run()
    dialog.destroy()
    
def receiveSubjectIdFromSerial():
    global subjectId
    
    msg = "No Subject ID was entered. Waiting to receive Subject ID on serial port."
    dialog = Gtk.MessageDialog(parent=view.window, type=Gtk.MessageType.INFO, buttons=Gtk.ButtonsType.CANCEL, text=msg)
    subjectId = ""
    endTimerCallback = False
    
    def timerCallback():
        global subjectId
        try:
            subjectId = ExpController.serialReceiveSubjectId()
        except:
            MsgLogger.append("Error receiving Subject ID.")
            dialog.destroy()
            return False    #do not call timerCallback again
        
        if subjectId != "":
            dialog.destroy()
            return False    #do not call timerCallback again
        else:
            if endTimerCallback:
                return False
            else:
                return True
    
    
    GLib.timeout_add(100,timerCallback)     #check every 100 ms
    
    dialog.run()
    dialog.destroy()
    
    if subjectId == "":     #id was not received or canceled
        endTimerCallback = True
    else:
        view.teSubjectId.set_text(subjectId) #update view with subject id

